/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
	BaseContract,
	BigNumberish,
	BytesLike,
	FunctionFragment,
	Result,
	Interface,
	EventFragment,
	AddressLike,
	ContractRunner,
	ContractMethod,
	Listener,
} from "ethers";
import type {
	TypedContractEvent,
	TypedDeferredTopicFilter,
	TypedEventLog,
	TypedLogDescription,
	TypedListener,
	TypedContractMethod,
} from "./common";

export declare namespace IOrderMixin {
	export type OrderStruct = {
		salt: BigNumberish;
		maker: BigNumberish;
		receiver: BigNumberish;
		makerAsset: BigNumberish;
		takerAsset: BigNumberish;
		makingAmount: BigNumberish;
		takingAmount: BigNumberish;
		makerTraits: BigNumberish;
	};

	export type OrderStructOutput = [
		salt: bigint,
		maker: bigint,
		receiver: bigint,
		makerAsset: bigint,
		takerAsset: bigint,
		makingAmount: bigint,
		takingAmount: bigint,
		makerTraits: bigint,
	] & {
		salt: bigint;
		maker: bigint;
		receiver: bigint;
		makerAsset: bigint;
		takerAsset: bigint;
		makingAmount: bigint;
		takingAmount: bigint;
		makerTraits: bigint;
	};
}

export declare namespace GenericRouter {
	export type SwapDescriptionStruct = {
		srcToken: AddressLike;
		dstToken: AddressLike;
		srcReceiver: AddressLike;
		dstReceiver: AddressLike;
		amount: BigNumberish;
		minReturnAmount: BigNumberish;
		flags: BigNumberish;
	};

	export type SwapDescriptionStructOutput = [
		srcToken: string,
		dstToken: string,
		srcReceiver: string,
		dstReceiver: string,
		amount: bigint,
		minReturnAmount: bigint,
		flags: bigint,
	] & {
		srcToken: string;
		dstToken: string;
		srcReceiver: string;
		dstReceiver: string;
		amount: bigint;
		minReturnAmount: bigint;
		flags: bigint;
	};
}

export interface AggregatorRouterV6Interface extends Interface {
	getFunction(
		nameOrSignature:
			| "advanceEpoch"
			| "and"
			| "arbitraryStaticCall"
			| "bitInvalidatorForOrder"
			| "bitsInvalidateForOrder"
			| "cancelOrder"
			| "cancelOrders"
			| "checkPredicate"
			| "clipperSwap"
			| "clipperSwapTo"
			| "curveSwapCallback"
			| "eip712Domain"
			| "epoch"
			| "epochEquals"
			| "eq"
			| "ethUnoswap"
			| "ethUnoswap2"
			| "ethUnoswap3"
			| "ethUnoswapTo"
			| "ethUnoswapTo2"
			| "ethUnoswapTo3"
			| "fillContractOrder"
			| "fillContractOrderArgs"
			| "fillOrder"
			| "fillOrderArgs"
			| "gt"
			| "hashOrder"
			| "increaseEpoch"
			| "lt"
			| "not"
			| "or"
			| "owner"
			| "pause"
			| "paused"
			| "permitAndCall"
			| "rawRemainingInvalidatorForOrder"
			| "remainingInvalidatorForOrder"
			| "renounceOwnership"
			| "rescueFunds"
			| "simulate"
			| "swap"
			| "transferOwnership"
			| "uniswapV3SwapCallback"
			| "unoswap"
			| "unoswap2"
			| "unoswap3"
			| "unoswapTo"
			| "unoswapTo2"
			| "unoswapTo3"
			| "unpause",
	): FunctionFragment;

	getEvent(
		nameOrSignatureOrTopic:
			| "BitInvalidatorUpdated"
			| "EIP712DomainChanged"
			| "EpochIncreased"
			| "OrderCancelled"
			| "OrderFilled"
			| "OwnershipTransferred"
			| "Paused"
			| "Unpaused",
	): EventFragment;

	encodeFunctionData(
		functionFragment: "advanceEpoch",
		values: [BigNumberish, BigNumberish],
	): string;
	encodeFunctionData(functionFragment: "and", values: [BigNumberish, BytesLike]): string;
	encodeFunctionData(
		functionFragment: "arbitraryStaticCall",
		values: [AddressLike, BytesLike],
	): string;
	encodeFunctionData(
		functionFragment: "bitInvalidatorForOrder",
		values: [AddressLike, BigNumberish],
	): string;
	encodeFunctionData(
		functionFragment: "bitsInvalidateForOrder",
		values: [BigNumberish, BigNumberish],
	): string;
	encodeFunctionData(functionFragment: "cancelOrder", values: [BigNumberish, BytesLike]): string;
	encodeFunctionData(
		functionFragment: "cancelOrders",
		values: [BigNumberish[], BytesLike[]],
	): string;
	encodeFunctionData(functionFragment: "checkPredicate", values: [BytesLike]): string;
	encodeFunctionData(
		functionFragment: "clipperSwap",
		values: [
			AddressLike,
			BigNumberish,
			AddressLike,
			BigNumberish,
			BigNumberish,
			BigNumberish,
			BytesLike,
			BytesLike,
		],
	): string;
	encodeFunctionData(
		functionFragment: "clipperSwapTo",
		values: [
			AddressLike,
			AddressLike,
			BigNumberish,
			AddressLike,
			BigNumberish,
			BigNumberish,
			BigNumberish,
			BytesLike,
			BytesLike,
		],
	): string;
	encodeFunctionData(
		functionFragment: "curveSwapCallback",
		values: [AddressLike, AddressLike, AddressLike, BigNumberish, BigNumberish],
	): string;
	encodeFunctionData(functionFragment: "eip712Domain", values?: undefined): string;
	encodeFunctionData(functionFragment: "epoch", values: [AddressLike, BigNumberish]): string;
	encodeFunctionData(
		functionFragment: "epochEquals",
		values: [AddressLike, BigNumberish, BigNumberish],
	): string;
	encodeFunctionData(functionFragment: "eq", values: [BigNumberish, BytesLike]): string;
	encodeFunctionData(functionFragment: "ethUnoswap", values: [BigNumberish, BigNumberish]): string;
	encodeFunctionData(
		functionFragment: "ethUnoswap2",
		values: [BigNumberish, BigNumberish, BigNumberish],
	): string;
	encodeFunctionData(
		functionFragment: "ethUnoswap3",
		values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
	): string;
	encodeFunctionData(
		functionFragment: "ethUnoswapTo",
		values: [BigNumberish, BigNumberish, BigNumberish],
	): string;
	encodeFunctionData(
		functionFragment: "ethUnoswapTo2",
		values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
	): string;
	encodeFunctionData(
		functionFragment: "ethUnoswapTo3",
		values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, BigNumberish],
	): string;
	encodeFunctionData(
		functionFragment: "fillContractOrder",
		values: [IOrderMixin.OrderStruct, BytesLike, BigNumberish, BigNumberish],
	): string;
	encodeFunctionData(
		functionFragment: "fillContractOrderArgs",
		values: [IOrderMixin.OrderStruct, BytesLike, BigNumberish, BigNumberish, BytesLike],
	): string;
	encodeFunctionData(
		functionFragment: "fillOrder",
		values: [IOrderMixin.OrderStruct, BytesLike, BytesLike, BigNumberish, BigNumberish],
	): string;
	encodeFunctionData(
		functionFragment: "fillOrderArgs",
		values: [IOrderMixin.OrderStruct, BytesLike, BytesLike, BigNumberish, BigNumberish, BytesLike],
	): string;
	encodeFunctionData(functionFragment: "gt", values: [BigNumberish, BytesLike]): string;
	encodeFunctionData(functionFragment: "hashOrder", values: [IOrderMixin.OrderStruct]): string;
	encodeFunctionData(functionFragment: "increaseEpoch", values: [BigNumberish]): string;
	encodeFunctionData(functionFragment: "lt", values: [BigNumberish, BytesLike]): string;
	encodeFunctionData(functionFragment: "not", values: [BytesLike]): string;
	encodeFunctionData(functionFragment: "or", values: [BigNumberish, BytesLike]): string;
	encodeFunctionData(functionFragment: "owner", values?: undefined): string;
	encodeFunctionData(functionFragment: "pause", values?: undefined): string;
	encodeFunctionData(functionFragment: "paused", values?: undefined): string;
	encodeFunctionData(functionFragment: "permitAndCall", values: [BytesLike, BytesLike]): string;
	encodeFunctionData(
		functionFragment: "rawRemainingInvalidatorForOrder",
		values: [AddressLike, BytesLike],
	): string;
	encodeFunctionData(
		functionFragment: "remainingInvalidatorForOrder",
		values: [AddressLike, BytesLike],
	): string;
	encodeFunctionData(functionFragment: "renounceOwnership", values?: undefined): string;
	encodeFunctionData(functionFragment: "rescueFunds", values: [AddressLike, BigNumberish]): string;
	encodeFunctionData(functionFragment: "simulate", values: [AddressLike, BytesLike]): string;
	encodeFunctionData(
		functionFragment: "swap",
		values: [AddressLike, GenericRouter.SwapDescriptionStruct, BytesLike],
	): string;
	encodeFunctionData(functionFragment: "transferOwnership", values: [AddressLike]): string;
	encodeFunctionData(
		functionFragment: "uniswapV3SwapCallback",
		values: [BigNumberish, BigNumberish, BytesLike],
	): string;
	encodeFunctionData(
		functionFragment: "unoswap",
		values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
	): string;
	encodeFunctionData(
		functionFragment: "unoswap2",
		values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, BigNumberish],
	): string;
	encodeFunctionData(
		functionFragment: "unoswap3",
		values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, BigNumberish, BigNumberish],
	): string;
	encodeFunctionData(
		functionFragment: "unoswapTo",
		values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, BigNumberish],
	): string;
	encodeFunctionData(
		functionFragment: "unoswapTo2",
		values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, BigNumberish, BigNumberish],
	): string;
	encodeFunctionData(
		functionFragment: "unoswapTo3",
		values: [
			BigNumberish,
			BigNumberish,
			BigNumberish,
			BigNumberish,
			BigNumberish,
			BigNumberish,
			BigNumberish,
		],
	): string;
	encodeFunctionData(functionFragment: "unpause", values?: undefined): string;

	decodeFunctionResult(functionFragment: "advanceEpoch", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "and", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "arbitraryStaticCall", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "bitInvalidatorForOrder", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "bitsInvalidateForOrder", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "cancelOrder", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "cancelOrders", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "checkPredicate", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "clipperSwap", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "clipperSwapTo", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "curveSwapCallback", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "eip712Domain", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "epoch", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "epochEquals", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "eq", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "ethUnoswap", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "ethUnoswap2", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "ethUnoswap3", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "ethUnoswapTo", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "ethUnoswapTo2", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "ethUnoswapTo3", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "fillContractOrder", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "fillContractOrderArgs", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "fillOrder", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "fillOrderArgs", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "gt", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "hashOrder", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "increaseEpoch", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "lt", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "not", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "or", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "permitAndCall", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "rawRemainingInvalidatorForOrder",
		data: BytesLike,
	): Result;
	decodeFunctionResult(functionFragment: "remainingInvalidatorForOrder", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "renounceOwnership", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "rescueFunds", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "simulate", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "swap", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "transferOwnership", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "uniswapV3SwapCallback", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "unoswap", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "unoswap2", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "unoswap3", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "unoswapTo", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "unoswapTo2", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "unoswapTo3", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
}

export namespace BitInvalidatorUpdatedEvent {
	export type InputTuple = [maker: AddressLike, slotIndex: BigNumberish, slotValue: BigNumberish];
	export type OutputTuple = [maker: string, slotIndex: bigint, slotValue: bigint];
	export interface OutputObject {
		maker: string;
		slotIndex: bigint;
		slotValue: bigint;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace EIP712DomainChangedEvent {
	export type InputTuple = [];
	export type OutputTuple = [];
	export interface OutputObject {}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace EpochIncreasedEvent {
	export type InputTuple = [maker: AddressLike, series: BigNumberish, newEpoch: BigNumberish];
	export type OutputTuple = [maker: string, series: bigint, newEpoch: bigint];
	export interface OutputObject {
		maker: string;
		series: bigint;
		newEpoch: bigint;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace OrderCancelledEvent {
	export type InputTuple = [orderHash: BytesLike];
	export type OutputTuple = [orderHash: string];
	export interface OutputObject {
		orderHash: string;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace OrderFilledEvent {
	export type InputTuple = [orderHash: BytesLike, remainingAmount: BigNumberish];
	export type OutputTuple = [orderHash: string, remainingAmount: bigint];
	export interface OutputObject {
		orderHash: string;
		remainingAmount: bigint;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferredEvent {
	export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
	export type OutputTuple = [previousOwner: string, newOwner: string];
	export interface OutputObject {
		previousOwner: string;
		newOwner: string;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace PausedEvent {
	export type InputTuple = [account: AddressLike];
	export type OutputTuple = [account: string];
	export interface OutputObject {
		account: string;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace UnpausedEvent {
	export type InputTuple = [account: AddressLike];
	export type OutputTuple = [account: string];
	export interface OutputObject {
		account: string;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export interface AggregatorRouterV6 extends BaseContract {
	connect(runner?: ContractRunner | null): AggregatorRouterV6;
	waitForDeployment(): Promise<this>;

	interface: AggregatorRouterV6Interface;

	queryFilter<TCEvent extends TypedContractEvent>(
		event: TCEvent,
		fromBlockOrBlockhash?: string | number | undefined,
		toBlock?: string | number | undefined,
	): Promise<Array<TypedEventLog<TCEvent>>>;
	queryFilter<TCEvent extends TypedContractEvent>(
		filter: TypedDeferredTopicFilter<TCEvent>,
		fromBlockOrBlockhash?: string | number | undefined,
		toBlock?: string | number | undefined,
	): Promise<Array<TypedEventLog<TCEvent>>>;

	on<TCEvent extends TypedContractEvent>(
		event: TCEvent,
		listener: TypedListener<TCEvent>,
	): Promise<this>;
	on<TCEvent extends TypedContractEvent>(
		filter: TypedDeferredTopicFilter<TCEvent>,
		listener: TypedListener<TCEvent>,
	): Promise<this>;

	once<TCEvent extends TypedContractEvent>(
		event: TCEvent,
		listener: TypedListener<TCEvent>,
	): Promise<this>;
	once<TCEvent extends TypedContractEvent>(
		filter: TypedDeferredTopicFilter<TCEvent>,
		listener: TypedListener<TCEvent>,
	): Promise<this>;

	listeners<TCEvent extends TypedContractEvent>(
		event: TCEvent,
	): Promise<Array<TypedListener<TCEvent>>>;
	listeners(eventName?: string): Promise<Array<Listener>>;
	removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>;

	advanceEpoch: TypedContractMethod<
		[series: BigNumberish, amount: BigNumberish],
		[void],
		"nonpayable"
	>;

	and: TypedContractMethod<[offsets: BigNumberish, data: BytesLike], [boolean], "view">;

	arbitraryStaticCall: TypedContractMethod<
		[target: AddressLike, data: BytesLike],
		[bigint],
		"view"
	>;

	bitInvalidatorForOrder: TypedContractMethod<
		[maker: AddressLike, slot: BigNumberish],
		[bigint],
		"view"
	>;

	bitsInvalidateForOrder: TypedContractMethod<
		[makerTraits: BigNumberish, additionalMask: BigNumberish],
		[void],
		"nonpayable"
	>;

	cancelOrder: TypedContractMethod<
		[makerTraits: BigNumberish, orderHash: BytesLike],
		[void],
		"nonpayable"
	>;

	cancelOrders: TypedContractMethod<
		[makerTraits: BigNumberish[], orderHashes: BytesLike[]],
		[void],
		"nonpayable"
	>;

	checkPredicate: TypedContractMethod<[predicate: BytesLike], [boolean], "view">;

	clipperSwap: TypedContractMethod<
		[
			clipperExchange: AddressLike,
			srcToken: BigNumberish,
			dstToken: AddressLike,
			inputAmount: BigNumberish,
			outputAmount: BigNumberish,
			goodUntil: BigNumberish,
			r: BytesLike,
			vs: BytesLike,
		],
		[bigint],
		"payable"
	>;

	clipperSwapTo: TypedContractMethod<
		[
			clipperExchange: AddressLike,
			recipient: AddressLike,
			srcToken: BigNumberish,
			dstToken: AddressLike,
			inputAmount: BigNumberish,
			outputAmount: BigNumberish,
			goodUntil: BigNumberish,
			r: BytesLike,
			vs: BytesLike,
		],
		[bigint],
		"payable"
	>;

	curveSwapCallback: TypedContractMethod<
		[
			arg0: AddressLike,
			arg1: AddressLike,
			inCoin: AddressLike,
			dx: BigNumberish,
			arg4: BigNumberish,
		],
		[void],
		"nonpayable"
	>;

	eip712Domain: TypedContractMethod<
		[],
		[
			[string, string, string, bigint, string, string, bigint[]] & {
				fields: string;
				name: string;
				version: string;
				chainId: bigint;
				verifyingContract: string;
				salt: string;
				extensions: bigint[];
			},
		],
		"view"
	>;

	epoch: TypedContractMethod<[maker: AddressLike, series: BigNumberish], [bigint], "view">;

	epochEquals: TypedContractMethod<
		[maker: AddressLike, series: BigNumberish, makerEpoch: BigNumberish],
		[boolean],
		"view"
	>;

	eq: TypedContractMethod<[value: BigNumberish, data: BytesLike], [boolean], "view">;

	ethUnoswap: TypedContractMethod<
		[minReturn: BigNumberish, dex: BigNumberish],
		[bigint],
		"payable"
	>;

	ethUnoswap2: TypedContractMethod<
		[minReturn: BigNumberish, dex: BigNumberish, dex2: BigNumberish],
		[bigint],
		"payable"
	>;

	ethUnoswap3: TypedContractMethod<
		[minReturn: BigNumberish, dex: BigNumberish, dex2: BigNumberish, dex3: BigNumberish],
		[bigint],
		"payable"
	>;

	ethUnoswapTo: TypedContractMethod<
		[to: BigNumberish, minReturn: BigNumberish, dex: BigNumberish],
		[bigint],
		"payable"
	>;

	ethUnoswapTo2: TypedContractMethod<
		[to: BigNumberish, minReturn: BigNumberish, dex: BigNumberish, dex2: BigNumberish],
		[bigint],
		"payable"
	>;

	ethUnoswapTo3: TypedContractMethod<
		[
			to: BigNumberish,
			minReturn: BigNumberish,
			dex: BigNumberish,
			dex2: BigNumberish,
			dex3: BigNumberish,
		],
		[bigint],
		"payable"
	>;

	fillContractOrder: TypedContractMethod<
		[
			order: IOrderMixin.OrderStruct,
			signature: BytesLike,
			amount: BigNumberish,
			takerTraits: BigNumberish,
		],
		[[bigint, bigint, string]],
		"nonpayable"
	>;

	fillContractOrderArgs: TypedContractMethod<
		[
			order: IOrderMixin.OrderStruct,
			signature: BytesLike,
			amount: BigNumberish,
			takerTraits: BigNumberish,
			args: BytesLike,
		],
		[[bigint, bigint, string]],
		"nonpayable"
	>;

	fillOrder: TypedContractMethod<
		[
			order: IOrderMixin.OrderStruct,
			r: BytesLike,
			vs: BytesLike,
			amount: BigNumberish,
			takerTraits: BigNumberish,
		],
		[[bigint, bigint, string]],
		"payable"
	>;

	fillOrderArgs: TypedContractMethod<
		[
			order: IOrderMixin.OrderStruct,
			r: BytesLike,
			vs: BytesLike,
			amount: BigNumberish,
			takerTraits: BigNumberish,
			args: BytesLike,
		],
		[[bigint, bigint, string]],
		"payable"
	>;

	gt: TypedContractMethod<[value: BigNumberish, data: BytesLike], [boolean], "view">;

	hashOrder: TypedContractMethod<[order: IOrderMixin.OrderStruct], [string], "view">;

	increaseEpoch: TypedContractMethod<[series: BigNumberish], [void], "nonpayable">;

	lt: TypedContractMethod<[value: BigNumberish, data: BytesLike], [boolean], "view">;

	not: TypedContractMethod<[data: BytesLike], [boolean], "view">;

	or: TypedContractMethod<[offsets: BigNumberish, data: BytesLike], [boolean], "view">;

	owner: TypedContractMethod<[], [string], "view">;

	pause: TypedContractMethod<[], [void], "nonpayable">;

	paused: TypedContractMethod<[], [boolean], "view">;

	permitAndCall: TypedContractMethod<[permit: BytesLike, action: BytesLike], [void], "payable">;

	rawRemainingInvalidatorForOrder: TypedContractMethod<
		[maker: AddressLike, orderHash: BytesLike],
		[bigint],
		"view"
	>;

	remainingInvalidatorForOrder: TypedContractMethod<
		[maker: AddressLike, orderHash: BytesLike],
		[bigint],
		"view"
	>;

	renounceOwnership: TypedContractMethod<[], [void], "nonpayable">;

	rescueFunds: TypedContractMethod<
		[token: AddressLike, amount: BigNumberish],
		[void],
		"nonpayable"
	>;

	simulate: TypedContractMethod<[target: AddressLike, data: BytesLike], [void], "nonpayable">;

	swap: TypedContractMethod<
		[executor: AddressLike, desc: GenericRouter.SwapDescriptionStruct, data: BytesLike],
		[[bigint, bigint] & { returnAmount: bigint; spentAmount: bigint }],
		"payable"
	>;

	transferOwnership: TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;

	uniswapV3SwapCallback: TypedContractMethod<
		[amount0Delta: BigNumberish, amount1Delta: BigNumberish, arg2: BytesLike],
		[void],
		"nonpayable"
	>;

	unoswap: TypedContractMethod<
		[token: BigNumberish, amount: BigNumberish, minReturn: BigNumberish, dex: BigNumberish],
		[bigint],
		"nonpayable"
	>;

	unoswap2: TypedContractMethod<
		[
			token: BigNumberish,
			amount: BigNumberish,
			minReturn: BigNumberish,
			dex: BigNumberish,
			dex2: BigNumberish,
		],
		[bigint],
		"nonpayable"
	>;

	unoswap3: TypedContractMethod<
		[
			token: BigNumberish,
			amount: BigNumberish,
			minReturn: BigNumberish,
			dex: BigNumberish,
			dex2: BigNumberish,
			dex3: BigNumberish,
		],
		[bigint],
		"nonpayable"
	>;

	unoswapTo: TypedContractMethod<
		[
			to: BigNumberish,
			token: BigNumberish,
			amount: BigNumberish,
			minReturn: BigNumberish,
			dex: BigNumberish,
		],
		[bigint],
		"nonpayable"
	>;

	unoswapTo2: TypedContractMethod<
		[
			to: BigNumberish,
			token: BigNumberish,
			amount: BigNumberish,
			minReturn: BigNumberish,
			dex: BigNumberish,
			dex2: BigNumberish,
		],
		[bigint],
		"nonpayable"
	>;

	unoswapTo3: TypedContractMethod<
		[
			to: BigNumberish,
			token: BigNumberish,
			amount: BigNumberish,
			minReturn: BigNumberish,
			dex: BigNumberish,
			dex2: BigNumberish,
			dex3: BigNumberish,
		],
		[bigint],
		"nonpayable"
	>;

	unpause: TypedContractMethod<[], [void], "nonpayable">;

	getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

	getFunction(
		nameOrSignature: "advanceEpoch",
	): TypedContractMethod<[series: BigNumberish, amount: BigNumberish], [void], "nonpayable">;
	getFunction(
		nameOrSignature: "and",
	): TypedContractMethod<[offsets: BigNumberish, data: BytesLike], [boolean], "view">;
	getFunction(
		nameOrSignature: "arbitraryStaticCall",
	): TypedContractMethod<[target: AddressLike, data: BytesLike], [bigint], "view">;
	getFunction(
		nameOrSignature: "bitInvalidatorForOrder",
	): TypedContractMethod<[maker: AddressLike, slot: BigNumberish], [bigint], "view">;
	getFunction(
		nameOrSignature: "bitsInvalidateForOrder",
	): TypedContractMethod<
		[makerTraits: BigNumberish, additionalMask: BigNumberish],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "cancelOrder",
	): TypedContractMethod<[makerTraits: BigNumberish, orderHash: BytesLike], [void], "nonpayable">;
	getFunction(
		nameOrSignature: "cancelOrders",
	): TypedContractMethod<
		[makerTraits: BigNumberish[], orderHashes: BytesLike[]],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "checkPredicate",
	): TypedContractMethod<[predicate: BytesLike], [boolean], "view">;
	getFunction(
		nameOrSignature: "clipperSwap",
	): TypedContractMethod<
		[
			clipperExchange: AddressLike,
			srcToken: BigNumberish,
			dstToken: AddressLike,
			inputAmount: BigNumberish,
			outputAmount: BigNumberish,
			goodUntil: BigNumberish,
			r: BytesLike,
			vs: BytesLike,
		],
		[bigint],
		"payable"
	>;
	getFunction(
		nameOrSignature: "clipperSwapTo",
	): TypedContractMethod<
		[
			clipperExchange: AddressLike,
			recipient: AddressLike,
			srcToken: BigNumberish,
			dstToken: AddressLike,
			inputAmount: BigNumberish,
			outputAmount: BigNumberish,
			goodUntil: BigNumberish,
			r: BytesLike,
			vs: BytesLike,
		],
		[bigint],
		"payable"
	>;
	getFunction(
		nameOrSignature: "curveSwapCallback",
	): TypedContractMethod<
		[
			arg0: AddressLike,
			arg1: AddressLike,
			inCoin: AddressLike,
			dx: BigNumberish,
			arg4: BigNumberish,
		],
		[void],
		"nonpayable"
	>;
	getFunction(nameOrSignature: "eip712Domain"): TypedContractMethod<
		[],
		[
			[string, string, string, bigint, string, string, bigint[]] & {
				fields: string;
				name: string;
				version: string;
				chainId: bigint;
				verifyingContract: string;
				salt: string;
				extensions: bigint[];
			},
		],
		"view"
	>;
	getFunction(
		nameOrSignature: "epoch",
	): TypedContractMethod<[maker: AddressLike, series: BigNumberish], [bigint], "view">;
	getFunction(
		nameOrSignature: "epochEquals",
	): TypedContractMethod<
		[maker: AddressLike, series: BigNumberish, makerEpoch: BigNumberish],
		[boolean],
		"view"
	>;
	getFunction(
		nameOrSignature: "eq",
	): TypedContractMethod<[value: BigNumberish, data: BytesLike], [boolean], "view">;
	getFunction(
		nameOrSignature: "ethUnoswap",
	): TypedContractMethod<[minReturn: BigNumberish, dex: BigNumberish], [bigint], "payable">;
	getFunction(
		nameOrSignature: "ethUnoswap2",
	): TypedContractMethod<
		[minReturn: BigNumberish, dex: BigNumberish, dex2: BigNumberish],
		[bigint],
		"payable"
	>;
	getFunction(
		nameOrSignature: "ethUnoswap3",
	): TypedContractMethod<
		[minReturn: BigNumberish, dex: BigNumberish, dex2: BigNumberish, dex3: BigNumberish],
		[bigint],
		"payable"
	>;
	getFunction(
		nameOrSignature: "ethUnoswapTo",
	): TypedContractMethod<
		[to: BigNumberish, minReturn: BigNumberish, dex: BigNumberish],
		[bigint],
		"payable"
	>;
	getFunction(
		nameOrSignature: "ethUnoswapTo2",
	): TypedContractMethod<
		[to: BigNumberish, minReturn: BigNumberish, dex: BigNumberish, dex2: BigNumberish],
		[bigint],
		"payable"
	>;
	getFunction(
		nameOrSignature: "ethUnoswapTo3",
	): TypedContractMethod<
		[
			to: BigNumberish,
			minReturn: BigNumberish,
			dex: BigNumberish,
			dex2: BigNumberish,
			dex3: BigNumberish,
		],
		[bigint],
		"payable"
	>;
	getFunction(
		nameOrSignature: "fillContractOrder",
	): TypedContractMethod<
		[
			order: IOrderMixin.OrderStruct,
			signature: BytesLike,
			amount: BigNumberish,
			takerTraits: BigNumberish,
		],
		[[bigint, bigint, string]],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "fillContractOrderArgs",
	): TypedContractMethod<
		[
			order: IOrderMixin.OrderStruct,
			signature: BytesLike,
			amount: BigNumberish,
			takerTraits: BigNumberish,
			args: BytesLike,
		],
		[[bigint, bigint, string]],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "fillOrder",
	): TypedContractMethod<
		[
			order: IOrderMixin.OrderStruct,
			r: BytesLike,
			vs: BytesLike,
			amount: BigNumberish,
			takerTraits: BigNumberish,
		],
		[[bigint, bigint, string]],
		"payable"
	>;
	getFunction(
		nameOrSignature: "fillOrderArgs",
	): TypedContractMethod<
		[
			order: IOrderMixin.OrderStruct,
			r: BytesLike,
			vs: BytesLike,
			amount: BigNumberish,
			takerTraits: BigNumberish,
			args: BytesLike,
		],
		[[bigint, bigint, string]],
		"payable"
	>;
	getFunction(
		nameOrSignature: "gt",
	): TypedContractMethod<[value: BigNumberish, data: BytesLike], [boolean], "view">;
	getFunction(
		nameOrSignature: "hashOrder",
	): TypedContractMethod<[order: IOrderMixin.OrderStruct], [string], "view">;
	getFunction(
		nameOrSignature: "increaseEpoch",
	): TypedContractMethod<[series: BigNumberish], [void], "nonpayable">;
	getFunction(
		nameOrSignature: "lt",
	): TypedContractMethod<[value: BigNumberish, data: BytesLike], [boolean], "view">;
	getFunction(nameOrSignature: "not"): TypedContractMethod<[data: BytesLike], [boolean], "view">;
	getFunction(
		nameOrSignature: "or",
	): TypedContractMethod<[offsets: BigNumberish, data: BytesLike], [boolean], "view">;
	getFunction(nameOrSignature: "owner"): TypedContractMethod<[], [string], "view">;
	getFunction(nameOrSignature: "pause"): TypedContractMethod<[], [void], "nonpayable">;
	getFunction(nameOrSignature: "paused"): TypedContractMethod<[], [boolean], "view">;
	getFunction(
		nameOrSignature: "permitAndCall",
	): TypedContractMethod<[permit: BytesLike, action: BytesLike], [void], "payable">;
	getFunction(
		nameOrSignature: "rawRemainingInvalidatorForOrder",
	): TypedContractMethod<[maker: AddressLike, orderHash: BytesLike], [bigint], "view">;
	getFunction(
		nameOrSignature: "remainingInvalidatorForOrder",
	): TypedContractMethod<[maker: AddressLike, orderHash: BytesLike], [bigint], "view">;
	getFunction(nameOrSignature: "renounceOwnership"): TypedContractMethod<[], [void], "nonpayable">;
	getFunction(
		nameOrSignature: "rescueFunds",
	): TypedContractMethod<[token: AddressLike, amount: BigNumberish], [void], "nonpayable">;
	getFunction(
		nameOrSignature: "simulate",
	): TypedContractMethod<[target: AddressLike, data: BytesLike], [void], "nonpayable">;
	getFunction(
		nameOrSignature: "swap",
	): TypedContractMethod<
		[executor: AddressLike, desc: GenericRouter.SwapDescriptionStruct, data: BytesLike],
		[[bigint, bigint] & { returnAmount: bigint; spentAmount: bigint }],
		"payable"
	>;
	getFunction(
		nameOrSignature: "transferOwnership",
	): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
	getFunction(
		nameOrSignature: "uniswapV3SwapCallback",
	): TypedContractMethod<
		[amount0Delta: BigNumberish, amount1Delta: BigNumberish, arg2: BytesLike],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "unoswap",
	): TypedContractMethod<
		[token: BigNumberish, amount: BigNumberish, minReturn: BigNumberish, dex: BigNumberish],
		[bigint],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "unoswap2",
	): TypedContractMethod<
		[
			token: BigNumberish,
			amount: BigNumberish,
			minReturn: BigNumberish,
			dex: BigNumberish,
			dex2: BigNumberish,
		],
		[bigint],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "unoswap3",
	): TypedContractMethod<
		[
			token: BigNumberish,
			amount: BigNumberish,
			minReturn: BigNumberish,
			dex: BigNumberish,
			dex2: BigNumberish,
			dex3: BigNumberish,
		],
		[bigint],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "unoswapTo",
	): TypedContractMethod<
		[
			to: BigNumberish,
			token: BigNumberish,
			amount: BigNumberish,
			minReturn: BigNumberish,
			dex: BigNumberish,
		],
		[bigint],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "unoswapTo2",
	): TypedContractMethod<
		[
			to: BigNumberish,
			token: BigNumberish,
			amount: BigNumberish,
			minReturn: BigNumberish,
			dex: BigNumberish,
			dex2: BigNumberish,
		],
		[bigint],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "unoswapTo3",
	): TypedContractMethod<
		[
			to: BigNumberish,
			token: BigNumberish,
			amount: BigNumberish,
			minReturn: BigNumberish,
			dex: BigNumberish,
			dex2: BigNumberish,
			dex3: BigNumberish,
		],
		[bigint],
		"nonpayable"
	>;
	getFunction(nameOrSignature: "unpause"): TypedContractMethod<[], [void], "nonpayable">;

	getEvent(
		key: "BitInvalidatorUpdated",
	): TypedContractEvent<
		BitInvalidatorUpdatedEvent.InputTuple,
		BitInvalidatorUpdatedEvent.OutputTuple,
		BitInvalidatorUpdatedEvent.OutputObject
	>;
	getEvent(
		key: "EIP712DomainChanged",
	): TypedContractEvent<
		EIP712DomainChangedEvent.InputTuple,
		EIP712DomainChangedEvent.OutputTuple,
		EIP712DomainChangedEvent.OutputObject
	>;
	getEvent(
		key: "EpochIncreased",
	): TypedContractEvent<
		EpochIncreasedEvent.InputTuple,
		EpochIncreasedEvent.OutputTuple,
		EpochIncreasedEvent.OutputObject
	>;
	getEvent(
		key: "OrderCancelled",
	): TypedContractEvent<
		OrderCancelledEvent.InputTuple,
		OrderCancelledEvent.OutputTuple,
		OrderCancelledEvent.OutputObject
	>;
	getEvent(
		key: "OrderFilled",
	): TypedContractEvent<
		OrderFilledEvent.InputTuple,
		OrderFilledEvent.OutputTuple,
		OrderFilledEvent.OutputObject
	>;
	getEvent(
		key: "OwnershipTransferred",
	): TypedContractEvent<
		OwnershipTransferredEvent.InputTuple,
		OwnershipTransferredEvent.OutputTuple,
		OwnershipTransferredEvent.OutputObject
	>;
	getEvent(
		key: "Paused",
	): TypedContractEvent<PausedEvent.InputTuple, PausedEvent.OutputTuple, PausedEvent.OutputObject>;
	getEvent(
		key: "Unpaused",
	): TypedContractEvent<
		UnpausedEvent.InputTuple,
		UnpausedEvent.OutputTuple,
		UnpausedEvent.OutputObject
	>;

	filters: {
		"BitInvalidatorUpdated(address,uint256,uint256)": TypedContractEvent<
			BitInvalidatorUpdatedEvent.InputTuple,
			BitInvalidatorUpdatedEvent.OutputTuple,
			BitInvalidatorUpdatedEvent.OutputObject
		>;
		BitInvalidatorUpdated: TypedContractEvent<
			BitInvalidatorUpdatedEvent.InputTuple,
			BitInvalidatorUpdatedEvent.OutputTuple,
			BitInvalidatorUpdatedEvent.OutputObject
		>;

		"EIP712DomainChanged()": TypedContractEvent<
			EIP712DomainChangedEvent.InputTuple,
			EIP712DomainChangedEvent.OutputTuple,
			EIP712DomainChangedEvent.OutputObject
		>;
		EIP712DomainChanged: TypedContractEvent<
			EIP712DomainChangedEvent.InputTuple,
			EIP712DomainChangedEvent.OutputTuple,
			EIP712DomainChangedEvent.OutputObject
		>;

		"EpochIncreased(address,uint256,uint256)": TypedContractEvent<
			EpochIncreasedEvent.InputTuple,
			EpochIncreasedEvent.OutputTuple,
			EpochIncreasedEvent.OutputObject
		>;
		EpochIncreased: TypedContractEvent<
			EpochIncreasedEvent.InputTuple,
			EpochIncreasedEvent.OutputTuple,
			EpochIncreasedEvent.OutputObject
		>;

		"OrderCancelled(bytes32)": TypedContractEvent<
			OrderCancelledEvent.InputTuple,
			OrderCancelledEvent.OutputTuple,
			OrderCancelledEvent.OutputObject
		>;
		OrderCancelled: TypedContractEvent<
			OrderCancelledEvent.InputTuple,
			OrderCancelledEvent.OutputTuple,
			OrderCancelledEvent.OutputObject
		>;

		"OrderFilled(bytes32,uint256)": TypedContractEvent<
			OrderFilledEvent.InputTuple,
			OrderFilledEvent.OutputTuple,
			OrderFilledEvent.OutputObject
		>;
		OrderFilled: TypedContractEvent<
			OrderFilledEvent.InputTuple,
			OrderFilledEvent.OutputTuple,
			OrderFilledEvent.OutputObject
		>;

		"OwnershipTransferred(address,address)": TypedContractEvent<
			OwnershipTransferredEvent.InputTuple,
			OwnershipTransferredEvent.OutputTuple,
			OwnershipTransferredEvent.OutputObject
		>;
		OwnershipTransferred: TypedContractEvent<
			OwnershipTransferredEvent.InputTuple,
			OwnershipTransferredEvent.OutputTuple,
			OwnershipTransferredEvent.OutputObject
		>;

		"Paused(address)": TypedContractEvent<
			PausedEvent.InputTuple,
			PausedEvent.OutputTuple,
			PausedEvent.OutputObject
		>;
		Paused: TypedContractEvent<
			PausedEvent.InputTuple,
			PausedEvent.OutputTuple,
			PausedEvent.OutputObject
		>;

		"Unpaused(address)": TypedContractEvent<
			UnpausedEvent.InputTuple,
			UnpausedEvent.OutputTuple,
			UnpausedEvent.OutputObject
		>;
		Unpaused: TypedContractEvent<
			UnpausedEvent.InputTuple,
			UnpausedEvent.OutputTuple,
			UnpausedEvent.OutputObject
		>;
	};
}
